public void Train(Network net)
{
    bool originalUseDropout = UseDropout;

    if (UseDropout)
    {
        hidden_layer1.SetDropoutTraining(true);
        hidden_layer2.SetDropoutTraining(true);
    }

    try
    {
        net.inputLayer = new InputLayer(NetworkMode.Train);
        int epochs = 10;
        Accuracy = new double[epochs];
        e_error_avr = new double[epochs];

        int totalSamples = net.inputLayer.Trainset.GetLength(0);

        for (int k = 0; k < epochs; k++)
        {
            e_error_avr[k] = 0;
            int correctPredictions = 0; // <-- СЧЁТЧИК ПРАВИЛЬНЫХ ОТВЕТОВ

            net.inputLayer.Shuffling_Array_Rows(net.inputLayer.Trainset);

            for (int i = 0; i < totalSamples; i++)
            {
                // Извлекаем входные признаки (15 значений)
                double[] tmpTrain = new double[15];
                for (int j = 0; j < tmpTrain.Length; j++)
                    tmpTrain[j] = net.inputLayer.Trainset[i, j + 1];

                // Прямой проход
                ForwardPass(net, tmpTrain);

                // === РАСЧЁТ ОШИБКИ (MSE) ===
                double tmpSumError = 0;
                double[] errors = new double[net.fact.Length];
                int trueClass = (int)net.inputLayer.Trainset[i, 0]; // истинный класс

                for (int x = 0; x < errors.Length; x++)
                {
                    if (x == trueClass)
                        errors[x] = 1.0 - net.fact[x];
                    else
                        errors[x] = -net.fact[x];

                    tmpSumError += errors[x] * errors[x] / 2.0;
                }
                e_error_avr[k] += tmpSumError / errors.Length;

                // === ПОДСЧЁТ ТОЧНОСТИ ===
                int predictedClass = Array.IndexOf(net.fact, net.fact.Max());
                if (predictedClass == trueClass)
                    correctPredictions++;

                // Обратное распространение
                double[] temp_gsums2 = net.output_layer.BackwardPass(errors);
                double[] temp_gsums1 = net.hidden_layer2.BackwardPass(temp_gsums2);
                net.hidden_layer1.BackwardPass(temp_gsums1);
            }

            // Усреднение ошибки по всем примерам
            e_error_avr[k] /= totalSamples;

            // === ПРАВИЛЬНЫЙ РАСЧЁТ ТОЧНОСТИ В ПРОЦЕНТАХ ===
            Accuracy[k] = (double)correctPredictions / totalSamples * 100.0;
        }
    }
    finally
    {
        hidden_layer1.SetDropoutTraining(originalUseDropout);
        hidden_layer2.SetDropoutTraining(originalUseDropout);
    }

    net.inputLayer = null;

    // Сохранение весов
    string memDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "memory");
    Directory.CreateDirectory(memDir); // на случай, если папка не создана

    net.hidden_layer1.WeightInitialize(MemoryMode.SET, Path.Combine(memDir, nameof(hidden_layer1) + "_memory.csv"));
    net.hidden_layer2.WeightInitialize(MemoryMode.SET, Path.Combine(memDir, nameof(hidden_layer2) + "_memory.csv"));
    net.output_layer.WeightInitialize(MemoryMode.SET, Path.Combine(memDir, nameof(output_layer) + "_memory.csv"));
}
