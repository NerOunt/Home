public void Train(Network net)
{
    bool originalUseDropout = UseDropout;

    if (UseDropout)
    {
        hidden_layer1.SetDropoutTraining(true);
        hidden_layer2.SetDropoutTraining(true);
    }

    try
    {
        net.inputLayer = new InputLayer(NetworkMode.Train);
        int epoches = 10;
        Accuracy = new double[epoches];
        double tmpSumError;
        double[] errors;
        double[] temp_gsums1;
        double[] temp_gsums2;
        e_error_avr = new double[epoches];

        int totalTrainSamples = net.inputLayer.Trainset.GetLength(0);

        for (int k = 0; k < epoches; k++)
        {
            e_error_avr[k] = 0;
            int correctPredictions = 0; // ← Счётчик правильных ответов

            net.inputLayer.Shuffling_Array_Rows(net.inputLayer.Trainset);

            for (int i = 0; i < totalTrainSamples; i++)
            {
                // Извлекаем признаки (15 значений), пропуская метку (первый столбец)
                double[] tmpTrain = new double[15];
                for (int j = 0; j < tmpTrain.Length; j++)
                    tmpTrain[j] = net.inputLayer.Trainset[i, j + 1];

                // Прямой проход
                ForwardPass(net, tmpTrain);

                // Вычисление ошибки (MSE)
                tmpSumError = 0;
                errors = new double[net.fact.Length];
                int trueLabel = (int)net.inputLayer.Trainset[i, 0]; // ← Истинная метка

                for (int x = 0; x < errors.Length; x++)
                {
                    if (x == trueLabel)
                        errors[x] = 1.0 - net.fact[x];
                    else
                        errors[x] = -net.fact[x];

                    tmpSumError += errors[x] * errors[x] / 2;
                }
                e_error_avr[k] += tmpSumError / errors.Length;

                // === НОВОЕ: Подсчёт точности ===
                int predictedLabel = Array.IndexOf(net.Fact, net.Fact.Max());
                if (predictedLabel == trueLabel)
                    correctPredictions++;
                // =============================

                // Обратное распространение
                temp_gsums2 = net.output_layer.BackwardPass(errors);
                temp_gsums1 = net.hidden_layer2.BackwardPass(temp_gsums2);
                net.hidden_layer1.BackwardPass(temp_gsums1);
            }

            // Усреднение ошибки по всему датасету
            e_error_avr[k] /= totalTrainSamples;

            // ← ПРАВИЛЬНАЯ ТОЧНОСТЬ: доля верных предсказаний
            Accuracy[k] = (double)correctPredictions / totalTrainSamples;
        }
    }
    finally
    {
        hidden_layer1.SetDropoutTraining(originalUseDropout);
        hidden_layer2.SetDropoutTraining(originalUseDropout);
    }

    // Освобождение ресурсов
    net.inputLayer = null;

    // Сохранение весов
    string memoryDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "memory");
    Directory.CreateDirectory(memoryDir); // На случай, если папки нет

    net.hidden_layer1.WeightInitialize(MemoryMode.SET, Path.Combine(memoryDir, nameof(hidden_layer1) + "_memory.csv"));
    net.hidden_layer2.WeightInitialize(MemoryMode.SET, Path.Combine(memoryDir, nameof(hidden_layer2) + "_memory.csv"));
    net.output_layer.WeightInitialize(MemoryMode.SET, Path.Combine(memoryDir, nameof(output_layer) + "_memory.csv"));
}

    net.inputLayer = null;

    // Сохранение весов
    string memDir = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "memory");
    Directory.CreateDirectory(memDir); // на случай, если папка не создана

    net.hidden_layer1.WeightInitialize(MemoryMode.SET, Path.Combine(memDir, nameof(hidden_layer1) + "_memory.csv"));
    net.hidden_layer2.WeightInitialize(MemoryMode.SET, Path.Combine(memDir, nameof(hidden_layer2) + "_memory.csv"));
    net.output_layer.WeightInitialize(MemoryMode.SET, Path.Combine(memDir, nameof(output_layer) + "_memory.csv"));
}
